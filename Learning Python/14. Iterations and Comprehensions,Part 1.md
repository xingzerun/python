## 迭代器：初探
for循环可以用于Python中任何序列类型，包括列表、元组以及字符串。  
实际上，for循环比这更为通用：可用于任何可迭代的对象。实际上，对Python中所有会从左至右扫描对象的迭代工具而言都是如此，这些迭代工具包括了for循环、列表解析、in成员关系测试以及map内置函数等。

“可迭代对象”，基本上，这就是序列观念的通用化：如果对象是实际保存的序列，或者可以在迭代工具环境中一次产生一个结果的对象，就看做是可迭代的。总之，可迭代对象包括实际序列和按照需求而计算的虚拟序列。

### 文件迭代器
已打开的文件对象有个方法名为readline，可以一次从一个文件读取一行文本，每次调用readline方法时，就会前进到下一列。到达文件末尾时，就会返回空字符串，我们通过它来检测，从而跳出循环。

	>>> f = open('script1.py')
	>>> f.readline()
	'import sys\n'
	...
	>>> f.readline()
	''
如今，文件也有一个方法，名为__next__,差多不有相同的效果：每次调用时，就会返回文件中的下一行。唯一值得注意的区别在于，到达文件末尾时，__next__会引发内置的StopIteration异常，而不是返回空字符串。

	>>> f = open('script1.py')
	>>> f.__next__()
	'import sys\n'
	...
	>>> f.__next__()
	StopIteration
这个接口就是Python中所谓的迭代协议：有__next__方法的对象会前进到下一个结果，而在一系列结果的末尾时，则会引发StopIteration。

魔法的效果就是，逐行读取文件的最佳方式就是根本不要去读取。

	>>> for line in open('script1.py'):
	>>> 	print(line.upper(), end='')
	...
	IMPORT SYS
	...
	PRINT(2 ** 33)
注意，这里的print使用end=''来抑制添加一个'\n'。上例是读取文件的最佳方式，原因有三：简单，运行最快，内存使用情况最好。相同效果的原始方式，是以for循环调用文件的readlines方法，将文件内容加载到内存，做成行字符串的列表。

	>>> for line in open('script1.py').readlines():
	>>> 	print(line.upper(), end='')
	...
	IMPORT SYS
	...
	PRINT(2 ** 33)

当然也可以用while循环逐行读取文件。

	>>> f = open('script1.py')
	>>> while True:
	... 	line = f.readline()
	... 	if not line: break
	... 	print(line.upper(), end='')
	...
	...same output...
这样比起迭代器for循环的版本，可能运行得更慢一些，因为迭代器在Python中是以C语言的速度运行的，而while循环版本则是通过Python虚拟机运行Python字节码的。
### 手动迭代：iter和next


### 其它内置类型迭代器

## 列表解析：初探

### 列表解析基础知识

### 在文件上使用列表解析

### 扩展的列表解析语法

## 其他迭代环境

## Python3.0中新的可迭代对象

### range迭代器

### map、zip和filter迭代器

### 多个迭代器 VS 单个迭代器

### 字典视图迭代器

## 其他迭代器主题
