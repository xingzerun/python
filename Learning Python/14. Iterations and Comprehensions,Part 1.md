## 迭代器：初探
for循环可以用于Python中任何序列类型，包括列表、元组以及字符串。  
实际上，for循环比这更为通用：可用于任何可迭代的对象。实际上，对Python中所有会从左至右扫描对象的迭代工具而言都是如此，这些迭代工具包括了for循环、列表解析、in成员关系测试以及map内置函数等。

“可迭代对象”，基本上，这就是序列观念的通用化：如果对象是实际保存的序列，或者可以在迭代工具环境中一次产生一个结果的对象，就看做是可迭代的。总之，可迭代对象包括实际序列和按照需求而计算的虚拟序列。

### 文件迭代器
已打开的文件对象有个方法名为readline，可以一次从一个文件读取一行文本，每次调用readline方法时，就会前进到下一列。到达文件末尾时，就会返回空字符串，我们通过它来检测，从而跳出循环。
```python
>>> f = open('script1.py')
>>> f.readline()
'import sys\n'
...
>>> f.readline()
...
```
如今，文件也有一个方法，名为__next__,差多不有相同的效果：每次调用时，就会返回文件中的下一行。唯一值得注意的区别在于，到达文件末尾时，__next__会引发内置的StopIteration异常，而不是返回空字符串。
```python
>>> f = open('script1.py')
>>> f.__next__()
'import sys\n'
...
>>> f.__next__()
StopIteration
```
这个接口就是Python中所谓的迭代协议：有__next__方法的对象会前进到下一个结果，而在一系列结果的末尾时，则会引发StopIteration。

魔法的效果就是，逐行读取文件的最佳方式就是根本不要去读取。
```python
>>> for line in open('script1.py'):
>>> 	print(line.upper(), end='')
...
IMPORT SYS
...
PRINT(2 ** 33)
```
注意，这里的print使用end=''来抑制添加一个'\n'。上例是读取文件的最佳方式，原因有三：简单，运行最快，内存使用情况最好。相同效果的原始方式，是以for循环调用文件的readlines方法，将文件内容加载到内存，做成行字符串的列表。
```python
>>> for line in open('script1.py').readlines():
>>> 	print(line.upper(), end='')
...
IMPORT SYS
...
PRINT(2 ** 33)
```
当然也可以用while循环逐行读取文件。
```python
>>> f = open('script1.py')
>>> while True:
... 	line = f.readline()
... 	if not line: break
... 	print(line.upper(), end='')
...
...same output...
```
这样比起迭代器for循环的版本，可能运行得更慢一些，因为迭代器在Python中是以C语言的速度运行的，而while循环版本则是通过Python虚拟机运行Python字节码的。
### 手动迭代：iter和next
从技术的角度，迭代协议还有一点值得注意。当for循环开始时，会通过它传给iter内置函数，以便从可迭代对象中获得一个迭代器，返回的对象含有需要的next方法。

列表以及很多其他的内置对象，不是自身的迭代器，因为它们支持多次打开迭代器。对这样的对象，我们必须调用iter来启动迭代。

从技术上来讲，for循环内部等价的I.__next__()，而不是next(I)。这两者几乎没有区别，但是Python3中有一些内置对象支持前者而不支持后者。

for循环和其他的迭代环境有时候针对用户定义的类不同地工作，重复地索引一个对象而不是运行迭代协议。
### 其它内置类型迭代器
在最新的Python版本中，字典有一个迭代器，在迭代环境中，会自动一次返回一个键。  
直接效果是，我们不再需要调用keys方法来遍历字典键。  

其他的Python对象类型也支持迭代协议，因此，也可以在for循环汇中使用。例如，shelves（用于Python对象的一个根据键访问的文件系统）和os.popen的结果（读取shell命令的输出的一个工具）也是可迭代的。  
在Python3.0中，它们支持P.__next__()方法，但不支持next(P)内置函数。

## 列表解析：初探
```python
>>> L = [1, 2, 3, 4, 5]

>>> for i in range(len(L)):
... 	L[i] += 10
...
>>> L
[11, 12, 13, 14, 15]
```
用产生所需的结果列表的一个单个表达式来替代该循环：
```python
>>> L = [x + 10 for x in L]
>>> L
[11, 12, 13, 14, 15]
```
直接结果是相同的，但是它需要较少的代码，并且可能会运行的更快。


### 列表解析基础知识
举一个例子：
```python
>>> L = [x + 10 for x in L]
```
列表解析写在一个方括号中，因为它们最终是构建一个新的列表的一种方式。它们以我们所组成的一个任意的表达式开始，这里为`x+ 10`


### 在文件上使用列表解析

### 扩展的列表解析语法

## 其他迭代环境

## Python3.0中新的可迭代对象

### range迭代器

### map、zip和filter迭代器

### 多个迭代器 VS 单个迭代器

### 字典视图迭代器

## 其他迭代器主题
